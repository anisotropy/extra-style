/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(1);\n__webpack_require__(2);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvZXh0cmEtc3R5bGUuanM/ZWQ0YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuL3N0YXRpYy1zdHlsZS5qcycpO1xucmVxdWlyZSgnLi9yZXNwLXN0eWxlLmpzJyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXBwL2V4dHJhLXN0eWxlLmpzXG4gKiogbW9kdWxlIGlkID0gMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("(function($){\n\t$.fn.extraStyle = function(arg, option){\n\t\tvar target = this.selector;\n\t\t$(document).ready(function(){\n\t\t\textraStyle(target, arg, option);\n\t\t});\n\t}\n\tfunction extraStyle(target, arg, option){if(target && arg){\n\t\t$(target).each(function(){\n\t\t\tvar $target = $(this);\n\t\t\tfor(var prop in arg){\n\t\t\t\tif(funcs[prop]) funcs[prop]($target, arg[prop], option);\n\t\t\t\telse $target.css(prop, arg[prop]);\n\t\t\t}\n\t\t});\n\t}}\n\tvar funcs = {\n\t\tratio: function($target, value, option){\n\t\t\tsetHeight();\n\t\t\tsetResize($target, $target, 'width', option);\n\n\t\t\t$target.on('resize', setHeight);\n\t\t\tif(option !== 'resize') $(window).resize(setHeight);\n\n\t\t\tfunction setHeight(){\n\t\t\t\t$target.outerHeight(getDim($target).width * value);\n\t\t\t}\n\t\t},\n\t\tfitted: function($target, value, option){ if($target.is('img') && value === 'yes'){\n\t\t\t$target.parent().css('overflow', 'hidden');\n\t\t\t$target.css('width', '100%');\n\t\t\tsetResize($target.parent(), $target, 'all', option);\n\n\t\t\t$target.on('load', fitAndCrop);\n\t\t\t$target.on('resize', fitAndCrop);\n\t\t\tif(option !== 'resize') $(window).resize(fitAndCrop);\n\n\t\t\tfunction fitAndCrop(){\n\t\t\t\t$target.css({ 'width': '', 'height': '', 'margin-left': '', 'margin-top': '' });\n\t\t\t\tvar width = getDim($target).width, height = getDim($target).height;\n\t\t\t\tvar wrapWidth = getDim($target.parent()).width, wrapHeight = getDim($target.parent()).height;\n\t\t\t\tvar ratio = wrapWidth / width;\n\t\t\t\tif(height * ratio < wrapHeight){\n\t\t\t\t\tratio = wrapHeight / height;\n\t\t\t\t\tvar nH = height * ratio;\n\t\t\t\t\tvar nW = width * ratio;\n\t\t\t\t\t$target.css({ width: nW, height: nH });\n\t\t\t\t\t$target.css({ 'margin-left': (wrapWidth-nW)/2, 'margin-top': 0 });\n\t\t\t\t} else {\n\t\t\t\t\tvar nH = height * ratio;\n\t\t\t\t\tvar nW = width * ratio;\n\t\t\t\t\t$target.css({ width: nW, height: nH });\n\t\t\t\t\t$target.css({ 'margin-top': (wrapHeight-nH)/2, 'margin-left': 0 });\n\t\t\t\t}\n\t\t\t}\n\t\t}}\n\t}\n\tfunction getDim($obj){\n\t\treturn $obj[0].getBoundingClientRect();\n\t}\n\tfunction setResize($wrap, $target, mode, option){\n\t\tif(option === 'resize' || option === \"resize-once\"){\n\t\t\tvar oldWidth = getDim($wrap).width;\n\t\t\tvar intv = setInterval(function(){\n\t\t\t\tvar newWidth = getDim($wrap).width;\n\t\t\t\tif(oldWidth != newWidth){\n\t\t\t\t\t$target.trigger('resize');\n\t\t\t\t\tif(option === 'resize-once') clearInterval(intv);\n\t\t\t\t\towidth = newWidth;\n\t\t\t\t}\n\t\t\t}, 100);\n\t\t}\n\t}\n\tfunction compareDim($one, $other, mode){\n\t\tvar one = getDim($one);\n\t\tvar other = getDim($other);\n\t\tif(mode === 'width'){\n\t\t\tif(one.width == other.width) return true; else false;\n\t\t}\n\t\telse if(mode === 'height'){\n\t\t\tif(one.height == other.height) return true; else false;\n\t\t}\n\t\telse {\n\t\t\tif(one.width == other.height && one.height == other.height) return true; else false;\n\t\t}\n\t}\n})(jQuery);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3RhdGljLXN0eWxlLmpzPzg2ZmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixpRUFBaUU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDLGtCQUFrQixtREFBbUQ7QUFDckUsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDLGtCQUFrQixvREFBb0Q7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oJCl7XG5cdCQuZm4uZXh0cmFTdHlsZSA9IGZ1bmN0aW9uKGFyZywgb3B0aW9uKXtcblx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5zZWxlY3Rvcjtcblx0XHQkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpe1xuXHRcdFx0ZXh0cmFTdHlsZSh0YXJnZXQsIGFyZywgb3B0aW9uKTtcblx0XHR9KTtcblx0fVxuXHRmdW5jdGlvbiBleHRyYVN0eWxlKHRhcmdldCwgYXJnLCBvcHRpb24pe2lmKHRhcmdldCAmJiBhcmcpe1xuXHRcdCQodGFyZ2V0KS5lYWNoKGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgJHRhcmdldCA9ICQodGhpcyk7XG5cdFx0XHRmb3IodmFyIHByb3AgaW4gYXJnKXtcblx0XHRcdFx0aWYoZnVuY3NbcHJvcF0pIGZ1bmNzW3Byb3BdKCR0YXJnZXQsIGFyZ1twcm9wXSwgb3B0aW9uKTtcblx0XHRcdFx0ZWxzZSAkdGFyZ2V0LmNzcyhwcm9wLCBhcmdbcHJvcF0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9fVxuXHR2YXIgZnVuY3MgPSB7XG5cdFx0cmF0aW86IGZ1bmN0aW9uKCR0YXJnZXQsIHZhbHVlLCBvcHRpb24pe1xuXHRcdFx0c2V0SGVpZ2h0KCk7XG5cdFx0XHRzZXRSZXNpemUoJHRhcmdldCwgJHRhcmdldCwgJ3dpZHRoJywgb3B0aW9uKTtcblxuXHRcdFx0JHRhcmdldC5vbigncmVzaXplJywgc2V0SGVpZ2h0KTtcblx0XHRcdGlmKG9wdGlvbiAhPT0gJ3Jlc2l6ZScpICQod2luZG93KS5yZXNpemUoc2V0SGVpZ2h0KTtcblxuXHRcdFx0ZnVuY3Rpb24gc2V0SGVpZ2h0KCl7XG5cdFx0XHRcdCR0YXJnZXQub3V0ZXJIZWlnaHQoZ2V0RGltKCR0YXJnZXQpLndpZHRoICogdmFsdWUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Zml0dGVkOiBmdW5jdGlvbigkdGFyZ2V0LCB2YWx1ZSwgb3B0aW9uKXsgaWYoJHRhcmdldC5pcygnaW1nJykgJiYgdmFsdWUgPT09ICd5ZXMnKXtcblx0XHRcdCR0YXJnZXQucGFyZW50KCkuY3NzKCdvdmVyZmxvdycsICdoaWRkZW4nKTtcblx0XHRcdCR0YXJnZXQuY3NzKCd3aWR0aCcsICcxMDAlJyk7XG5cdFx0XHRzZXRSZXNpemUoJHRhcmdldC5wYXJlbnQoKSwgJHRhcmdldCwgJ2FsbCcsIG9wdGlvbik7XG5cblx0XHRcdCR0YXJnZXQub24oJ2xvYWQnLCBmaXRBbmRDcm9wKTtcblx0XHRcdCR0YXJnZXQub24oJ3Jlc2l6ZScsIGZpdEFuZENyb3ApO1xuXHRcdFx0aWYob3B0aW9uICE9PSAncmVzaXplJykgJCh3aW5kb3cpLnJlc2l6ZShmaXRBbmRDcm9wKTtcblxuXHRcdFx0ZnVuY3Rpb24gZml0QW5kQ3JvcCgpe1xuXHRcdFx0XHQkdGFyZ2V0LmNzcyh7ICd3aWR0aCc6ICcnLCAnaGVpZ2h0JzogJycsICdtYXJnaW4tbGVmdCc6ICcnLCAnbWFyZ2luLXRvcCc6ICcnIH0pO1xuXHRcdFx0XHR2YXIgd2lkdGggPSBnZXREaW0oJHRhcmdldCkud2lkdGgsIGhlaWdodCA9IGdldERpbSgkdGFyZ2V0KS5oZWlnaHQ7XG5cdFx0XHRcdHZhciB3cmFwV2lkdGggPSBnZXREaW0oJHRhcmdldC5wYXJlbnQoKSkud2lkdGgsIHdyYXBIZWlnaHQgPSBnZXREaW0oJHRhcmdldC5wYXJlbnQoKSkuaGVpZ2h0O1xuXHRcdFx0XHR2YXIgcmF0aW8gPSB3cmFwV2lkdGggLyB3aWR0aDtcblx0XHRcdFx0aWYoaGVpZ2h0ICogcmF0aW8gPCB3cmFwSGVpZ2h0KXtcblx0XHRcdFx0XHRyYXRpbyA9IHdyYXBIZWlnaHQgLyBoZWlnaHQ7XG5cdFx0XHRcdFx0dmFyIG5IID0gaGVpZ2h0ICogcmF0aW87XG5cdFx0XHRcdFx0dmFyIG5XID0gd2lkdGggKiByYXRpbztcblx0XHRcdFx0XHQkdGFyZ2V0LmNzcyh7IHdpZHRoOiBuVywgaGVpZ2h0OiBuSCB9KTtcblx0XHRcdFx0XHQkdGFyZ2V0LmNzcyh7ICdtYXJnaW4tbGVmdCc6ICh3cmFwV2lkdGgtblcpLzIsICdtYXJnaW4tdG9wJzogMCB9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgbkggPSBoZWlnaHQgKiByYXRpbztcblx0XHRcdFx0XHR2YXIgblcgPSB3aWR0aCAqIHJhdGlvO1xuXHRcdFx0XHRcdCR0YXJnZXQuY3NzKHsgd2lkdGg6IG5XLCBoZWlnaHQ6IG5IIH0pO1xuXHRcdFx0XHRcdCR0YXJnZXQuY3NzKHsgJ21hcmdpbi10b3AnOiAod3JhcEhlaWdodC1uSCkvMiwgJ21hcmdpbi1sZWZ0JzogMCB9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH19XG5cdH1cblx0ZnVuY3Rpb24gZ2V0RGltKCRvYmope1xuXHRcdHJldHVybiAkb2JqWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHR9XG5cdGZ1bmN0aW9uIHNldFJlc2l6ZSgkd3JhcCwgJHRhcmdldCwgbW9kZSwgb3B0aW9uKXtcblx0XHRpZihvcHRpb24gPT09ICdyZXNpemUnIHx8IG9wdGlvbiA9PT0gXCJyZXNpemUtb25jZVwiKXtcblx0XHRcdHZhciBvbGRXaWR0aCA9IGdldERpbSgkd3JhcCkud2lkdGg7XG5cdFx0XHR2YXIgaW50diA9IHNldEludGVydmFsKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHZhciBuZXdXaWR0aCA9IGdldERpbSgkd3JhcCkud2lkdGg7XG5cdFx0XHRcdGlmKG9sZFdpZHRoICE9IG5ld1dpZHRoKXtcblx0XHRcdFx0XHQkdGFyZ2V0LnRyaWdnZXIoJ3Jlc2l6ZScpO1xuXHRcdFx0XHRcdGlmKG9wdGlvbiA9PT0gJ3Jlc2l6ZS1vbmNlJykgY2xlYXJJbnRlcnZhbChpbnR2KTtcblx0XHRcdFx0XHRvd2lkdGggPSBuZXdXaWR0aDtcblx0XHRcdFx0fVxuXHRcdFx0fSwgMTAwKTtcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gY29tcGFyZURpbSgkb25lLCAkb3RoZXIsIG1vZGUpe1xuXHRcdHZhciBvbmUgPSBnZXREaW0oJG9uZSk7XG5cdFx0dmFyIG90aGVyID0gZ2V0RGltKCRvdGhlcik7XG5cdFx0aWYobW9kZSA9PT0gJ3dpZHRoJyl7XG5cdFx0XHRpZihvbmUud2lkdGggPT0gb3RoZXIud2lkdGgpIHJldHVybiB0cnVlOyBlbHNlIGZhbHNlO1xuXHRcdH1cblx0XHRlbHNlIGlmKG1vZGUgPT09ICdoZWlnaHQnKXtcblx0XHRcdGlmKG9uZS5oZWlnaHQgPT0gb3RoZXIuaGVpZ2h0KSByZXR1cm4gdHJ1ZTsgZWxzZSBmYWxzZTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZihvbmUud2lkdGggPT0gb3RoZXIuaGVpZ2h0ICYmIG9uZS5oZWlnaHQgPT0gb3RoZXIuaGVpZ2h0KSByZXR1cm4gdHJ1ZTsgZWxzZSBmYWxzZTtcblx0XHR9XG5cdH1cbn0pKGpRdWVyeSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXBwL3N0YXRpYy1zdHlsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 2 */
/***/ function(module, exports) {

	eval("(function($){\n\tvar _bp = [320, 768, 1024, 1280];\n\tvar setScrollbarEvent = false;\n\n\t$(window).on('es-setScrollbarEvent', function(){\n\t\tif(setScrollbarEvent !== false) return;\n\t\tsetScrollbarEvent = true;\n\n\t\tvar scrollbar = (window.innerWidth != $(window).outerWidth());\n\t\tsetInterval(function(){\n\t\t\tif(scrollbar && window.innerWidth == $(window).outerWidth()){\n\t\t\t\t$(window).trigger('es-changeScrollbar'); scrollbar = false;\n\t\t\t} else if(!scrollbar && window.innerWidth != $(window).outerWidth()){\n\t\t\t\t$(window).trigger('es-changeScrollbar'); scrollbar = true;\n\t\t\t}\n\t\t}, 100);\n\t});\n\t$.respStyle = function(arg){if(arg){\n\t\tvar array = arg.split(' ');\n\t\tif(array.length < 2){ console.error('Error: the length of break points'); return false; }\n\t\t_bp = [];\n\t\tfor(var i = 0, len = array.length; i < len; i++){\n\t\t\tif($.isNumeric(array[i])) _bp.push(parseFloat(array[i]));\n\t\t}\n\t}}\n\t$.fn.respStyle = function(arg){\n\t\tvar target = this.selector;\n\t\t$(document).ready(function(){\n\t\t\trespStyle(target, arg);\n\t\t});\n\t}\n\tfunction respStyle(target, arg){if(target && arg){\n\t\t$(target).each(function(){\n\t\t\tvar $target = $(this);\n\t\t\tvar style = new Style(arg);\n\t\t\t$target.css(style.css());\n\t\t\t$(window).resize(function(){\n\t\t\t\t$target.css(style.css());\n\t\t\t});\n\t\t});\n\t}}\n\t$.fn.respGrid = function(arg){\n\t\tvar target = this.selector;\n\t\t$(document).ready(function(){\n\t\t\trespGrid(target, arg);\n\t\t});\n\t}\n\tfunction respGrid(target, arg){if(target && arg){\n\t\t$(target).each(function(){\n\t\t\t$(this).css('overflow', 'hidden');\n\t\t\t$(this).children('div').addClass('es').addClass('es-cell').css({float: 'left', overflow: 'hidden'});\n\t\t\tif($(this).is('.es.es-cell')) $(this).addClass('es-nested');\n\t\t\tvar $target = $(this);\n\t\t\tvar grid = new Grid(arg, $target.children('.es.es-cell').length);\n\t\t\tgrid.adjust($target);\n\t\t\t$(window).resize(function(){\n\t\t\t\tgrid.adjust($target);\n\t\t\t});\n\t\t\t$(window).on('es-changeScrollbar', function(){\n\t\t\t\tgrid.adjust($target, false);\n\t\t\t});\n\t\t});\n\t}}\n\n\t// style ////\n\tfunction Style(arg){\n\t\tvar this_data = {};\n\t\tvar this_bp = { bp: undefined, bpi: 0, ww: 0 };\n\t\tvar this_style = {};\n\t\tthis.css = function(calc){\n\t\t\tif(calc === undefined || calc) this.calcStyle(this_data, this_bp, this_style);\n\t\t\treturn this_style;\n\t\t}\n\t\t//initialize ////\n\t\tif(arg){\n\t\t\tthis.convToObj(arg, this_data, this_bp);\n\t\t\tthis.postConv(this_data, this_bp);\n\t\t}\n\t}\n\tStyle.prototype.convToObj = function(arg, data, bp){\n\t\tfor(var prop in arg){\n\t\t\tif(prop !== 'breakpoint'){\n\t\t\t\tdata[prop] = { series: [], max: false, unit: 'px', func: 'linear'};\n\t\t\t\tthis.convToObjEach(arg[prop], data[prop]);\n\t\t\t} else {\n\t\t\t\tbp.bp = [];\n\t\t\t\tthis.convToObjEach(arg[prop], bp.bp);\n\t\t\t}\n\t\t}\n\t\tif(bp.bp === undefined) bp.bp = _bp;\n\t}\n\tStyle.prototype.convToObjEach = function(propOfArg, propOfData){\n\t\tvar array = propOfArg.split(' ');\n\t\tif(array.length < 1){ console.error('Error: the length of argument'); return false; }\n\t\tif($.type(propOfData) === 'object'){\n\t\t\tfor(var i = 0, len = array.length; i < len; i++){\n\t\t\t\tif($.isNumeric(array[i])) propOfData.series.push(parseFloat(array[i]));\n\t\t\t\telse if(array[i] === '-' || array[i] === '=') propOfData.series.push(array[i]);\n\t\t\t\telse if(this.isNotNumVal(array[i])) propOfData.series.push(array[i]);\n\t\t\t\telse if(this.isUnit(array[i])) propOfData.unit = array[i];\n\t\t\t\telse if(array[i] === 'max') propOfData.max = true;\n\t\t\t\telse if(array[i] === 'linear' || array[i] === 'step' || array[i] === 'saw') propOfData.func = array[i];\n\t\t\t}\n\t\t} else if($.type(propOfData) === 'array'){\n\t\t\tfor(var i = 0, len = array.length; i < len; i++){\n\t\t\t\tif($.isNumeric(array[i])) propOfData.push(parseFloat(array[i]));\n\t\t\t\telse if(array[i] === '-' || array[i] === '=') propOfData.push(array[i]);\n\t\t\t\telse if(this.isNotNumVal(array[i])) propOfData.push(array[i]);\n\t\t\t}\n\t\t}\n\t}\n\tStyle.prototype.postConv = function(data, bp){\n\t\tfor(var prop in data){\n\t\t\tthis.validateEach(data[prop], bp.bp.length);\n\t\t\tthis.calcMiddleEach(data[prop], bp.bp);\n\t\t\tthis.calcEqualEach(data[prop]);\n\t\t}\n\t}\n\tStyle.prototype.validateEach = function(propOfData, bpLength){\n\t\tif($.type(propOfData) === 'object'){\n\t\t\tif(propOfData.func !== 'saw' && propOfData.series.length < bpLength){\n\t\t\t\tfor(var i = propOfData.series.length, len = bpLength; i < len; i++){\n\t\t\t\t\tpropOfData.series[i] = propOfData.series[i-1];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(propOfData.func === 'saw' && propOfData.series.length <bpLength*2){\n\t\t\t\tfor(var i = propOfData.series.length, len = bpLength*2; i < len; i++){\n\t\t\t\t\tpropOfData.series[i] = propOfData.series[i-1];\n\t\t\t\t}\n\t\t\t}\n\t\t} else if($.type(propOfData) === 'array'){\n\t\t\tif(propOfData.length < bpLength){\n\t\t\t\tfor(var i = propOfData.length, len = bpLength; i < len; i++){\n\t\t\t\t\tpropOfData[i] = propOfData[i-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tStyle.prototype.calcMiddleEach = function(propOfData, bp){\n\t\tvar series;\n\t\tif($.type(propOfData) === 'object') series = propOfData.series;\n\t\telse if($.type(propOfData) === 'array') series = propOfData;\n\t\tvar pni = 0, nni = 0;\n\t\tif(series[0] === '-'){ console.error('Wrong usage of \"-\"'); return; }\n\t\tfor(var i = 0, len = series.length; i < len-1; i++){\n\t\t\tif($.isNumeric(series[i])) pni = i;\n\t\t\tif(series[i] === '-'){\n\t\t\t\tif(nni === 0 || nni < i){\n\t\t\t\t\tfor(var j = i+1; j < len; j++){\n\t\t\t\t\t\tif($.isNumeric(series[j])){ nni = j; break; }\n\t\t\t\t\t}\n\t\t\t\t\tif(nni === 0 || nni < i) {\n\t\t\t\t\t\tconsole.error('Wrong usage of \"-\"'); return;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tseries[i] = (series[nni] - series[pni]) * (bp[i] - bp[pni]) / (bp[nni] - bp[pni]) + series[pni];\n\t\t\t}\n\t\t}\n\n\t}\n\tStyle.prototype.calcEqualEach = function(propOfData){\n\t\tvar series;\n\t\tif($.type(propOfData) === 'object') series = propOfData.series;\n\t\telse if($.type(propOfData) === 'array') series = propOfData;\n\t\tif(series[0] === '='){ console.error('Wrong usage of \"=\"'); return; }\n\t\tfor(var i = 1, len = series.length; i < len; i++){\n\t\t\tif(series[i] === '=') series[i] = series[i-1];\n\t\t}\n\t}\n\tStyle.prototype.calcStyle = function(data, bp, style){\n\t\tthis.findBp(bp);\n\t\tfor(var prop in data){\n\t\t\tif(!this.isNotNumProp(prop)){\n\t\t\t\tstyle[prop] = this.calc(data[prop], bp) + data[prop].unit;\n\t\t\t} else {\n\t\t\t\tstyle[prop] = this.pick(data[prop].series, bp);\n\t\t\t}\n\t\t}\n\t}\n\tStyle.prototype.findBp = function(bp){\n\t\tbp.ww = window.innerWidth;\n\t\tif(bp.ww < bp.bp[0]) bp.bpi = -1;\n\t\telse if(bp.ww >=  bp.bp[bp.bp.length-1]) bp.bpi = -2;\n\t\telse { for(var i = 0; i < bp.bp.length-1; i++){\n\t\t\tif(bp.bp[i] <= bp.ww && bp.ww < bp.bp[i+1]){ bp.bpi = i; break; }\n\t\t}}\n\t}\n\tStyle.prototype.pick = function(series, bp){\n\t\tif(bp.bpi >= 0) return series[bp.bpi];\n\t\telse if(bp.bpi == -1) return series[0];\n\t\telse if(bp.bpi == -2) return series[bp.bp.length-1];\n\t}\n\tStyle.prototype.calc = function(propOfData, this_bp){\n\t\tvar series = propOfData.series, max = propOfData.max, func = propOfData.func;\n\t\tvar bp = this_bp.bp, bpi = this_bp.bpi, len = this_bp.bp.length, ww = this_bp.ww;\n\t\tvar i;\n\t\tif(bpi >= 0){\n\t\t\ti = bpi;\n\t\t} else if(bpi === -1){\n\t\t\treturn series[0];\n\t\t} else if(bpi === -2){\n\t\t\tif(max){\n\t\t\t\tif(func !== 'saw') return series[len-1];\n\t\t\t\telse if(func === 'saw') return series[2*(len-1)+1];\n\t\t\t} else {\n\t\t\t\tif(func === 'linear' || func === 'saw'){ i = len-2; }\n\t\t\t\telse if(func === 'step') i = len - 1;\n\t\t\t}\n\t\t}\n\n\t\tif(func === 'step'){\n\t\t\treturn series[i];\n\t\t} else if(func === 'linear'){\n\t\t\tif(bpi >= 0)\n\t\t\t\treturn (series[i+1] - series[i]) * (ww - bp[i]) / (bp[i+1] - bp[i]) + series[i];\n\t\t\telse\n\t\t\t\treturn (series[i+1] - series[i]) * (ww - bp[i+1]) / (bp[i+1] - bp[i]) + series[i+1];\n\t\t} else if(func === 'saw'){\n\t\t\tif(bpi >= 0)\n\t\t\t\treturn (series[i*2+1] - series[i*2]) * (ww - bp[i]) / (bp[i+1] - bp[i]) + series[i*2];\n\t\t\telse\n\t\t\t\treturn (series[i*2+3] - series[i*2+2]) * (ww - bp[i]) / (bp[i+1] - bp[i]) + series[i*2+2];\n\t\t}\n\t}\n\tStyle.prototype.isUnit = function(unit){\n\t\tvar units = ['em', 'ex', '%', 'px', 'cm', 'mm', 'in', 'pt', 'pc', 'ch', 'rem', 'vh', 'vw', 'vmin', 'vmax'];\n\t\tif($.inArray(unit, units) > -1) return true; else return false;\n\t}\n\tStyle.prototype.isNotNumVal = function(value){\n\t\tvar values = ['left', 'right', 'none', 'absolute', 'fixed', 'static', 'hidden', 'scroll', 'auto',\n\t\t\t'block', 'inline', 'inline-block'];\n\t\tif($.inArray(value, values) > -1) return true; else return false;\n\t}\n\tStyle.prototype.isNotNumProp = function(prop){\n\t\tvar props = ['float', 'position', 'overflow', 'overflow-x', 'overflow-y', 'display'];\n\t\tif($.inArray(prop, props) > -1) return true; else return false;\n\t}\n\n\t// grid ////\n\tfunction Grid(arg, numCell){\n\t\tvar this_data = {\n\t\t\tcolumns: [], ratio: [],\n\t\t\tgutter: {series: [], max: false, func: 'linear'}, //gutter의 unit은 px.\n\t\t\tcells: new Array(numCell)\n\t\t};\n\t\tvar this_bp = { bp: undefined, bpi: 0, ww: 0 };\n\t\tvar this_current = { columns: 0, ratio: 0, gutter: 0 , cells: new Array(numCell) };\n\t\tthis.adjust = function($target, cell){\n\t\t\tif(cell === undefined || cell){\n\t\t\t\tthis.calcCurrent(this_data, this_bp, this_current);\n\t\t\t\tthis.adjustCell(this_current, $target);\n\t\t\t} else {\n\t\t\t\tthis.adjustCellWidth(this_current, $target);\n\t\t\t}\n\t\t}\n\t\t//initialize ////\n\t\tif(arg){\n\t\t\tthis.convToObj(arg, this_data, this_bp);\n\t\t\tthis.postConv(this_data, this_bp);\n\t\t}\n\t}\n\tGrid.prototype = new Style();\n\tGrid.prototype.convToObj = function(arg, data, bp){\n\t\tif(arg.breakpoint){\n\t\t\tbp.bp = []; this.convToObjEach(arg.breakpoint, bp.bp);\n\t\t} else {\n\t\t\tbp.bp = _bp;\n\t\t}\n\t\tfor(var prop in arg){\n\t\t\tif(data[prop]) this.convToObjEach(arg[prop], data[prop]);\n\t\t\telse if(prop.match(/^cell/)){\n\t\t\t\tvar index = parseInt(prop.replace(/^cell/, ''));\n\t\t\t\tdata.cells[index] = [];\n\t\t\t\tthis.convToObjEach(arg[prop], data.cells[index]);\n\t\t\t}\n\t\t}\n\t}\n\tGrid.prototype.postConv = function(data, bp){\n\t\tfor(var prop in data){\n\t\t\tif(prop !== 'cells'){\n\t\t\t\tthis.validateEach(data[prop], bp.bp.length);\n\t\t\t\tthis.calcMiddleEach(data[prop], bp.bp);\n\t\t\t\tthis.calcEqualEach(data[prop]);\n\t\t\t} else {\n\t\t\t\tfor(var i = 0, len = data[prop].length; i < len; i++){\n\t\t\t\t\tif(data[prop][i]){\n\t\t\t\t\t\tthis.validateEach(data[prop][i], bp.bp.length);\n\t\t\t\t\t\tthis.calcMiddleEach(data[prop][i], bp);\n\t\t\t\t\t\tthis.calcEqualEach(data[prop][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tGrid.prototype.calcCurrent = function(data, this_bp, current){\n\t\tthis.findBp(this_bp);\n\t\tcurrent.gutter = this.calc(data.gutter, this_bp);\n\t\tvar bpi;\n\t\tif(this_bp.bpi >= 0) bpi = this_bp.bpi;\n\t\telse if(this_bp.bpi === -2) bpi = this_bp.bp.length-1;\n\t\telse if(this_bp.bpi === -1) bpi = 0;\n\t\tcurrent.columns = data.columns[bpi];\n\t\tcurrent.ratio = data.ratio[bpi];\n\t\tfor(var i = 0, len = data.cells.length; i < len; i++){\n\t\t\t if(data.cells[i]) current.cells[i] = data.cells[i][bpi];\n\t\t\t else current.cells[i] = 1;\n\t\t}\n\t}\n\tGrid.prototype.adjustCell = function(current, $target){\n\t\tvar preW = $target.outerWidth();\n\t\tvar gut = current.gutter;\n\t\tvar cols = current.columns;\n\t\tvar cells = current.cells;\n\t\tvar $cells = $target.children('.es.es-cell');\n\t\tvar length = $cells.length;\n\t\tvar cw = (this.getDim($target).width - gut*(cols-1))/cols;\n\t\tvar maxCh = 0;\n\t\t$cells.css({'margin-right': 0, 'margin-top': 0});\n\t\tif(current.ratio !== 'auto') $cells.css({width: 0, height: 0});\n\t\telse $cells.css({width: 0, height: 0});\n\t\t$cells.each(function(index){\n\t\t\t$(this).outerWidth(cw*cells[index] + gut*(cells[index]-1));\n\t\t\tif((index+1) % cols !== 0 && index < length-1) $(this).css({'margin-right': gut});\n\t\t\tif(index >= cols) $(this).css({'margin-top': gut});\n\t\t\tif(current.ratio === 'auto'){\n\t\t\t\t$(this).css({height: ''});\n\t\t\t\tif(maxCh < this.getDim($(this)).height) maxCh = this.getDim($(this)).height;\n\t\t\t\tif(cols !== 1 && (index+1) % cols === 0){\n\t\t\t\t\tfor(var i = index - cols + 1; i <= index; i++) $cells.eq(i).outerHeight(maxCh);\n\t\t\t\t\tmaxCh = 0;\n\t\t\t\t} else if(cols !== 1 && index === length-1) {\n\t\t\t\t\tfor(var i = Math.floor((index+1)/cols) * cols; i <= index; i++) $cells.eq(i).outerHeight(maxCh);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar height = cw * current.ratio;\n\t\t\t\tif($target.is('.es.es-nested')) height -= (gut - gut/Math.ceil(length/cols));\n\t\t\t\t$(this).outerHeight(height);\n\t\t\t}\n\t\t});\n\t\tif(preW != $target.outerWidth()){\n\t\t\tcw = (this.getDim($target).width - gut*(cols-1))/cols;\n\t\t\t$cells.each(function(index){ $(this).outerWidth(cw*cells[index] + gut*(cells[index]-1)); });\n\t\t}\n\t}\n\tGrid.prototype.adjustCellWidth = function(current, $target){\n\t\tvar gut = current.gutter;\n\t\tvar cols = current.columns;\n\t\tvar cells = current.cells;\n\t\tvar $cells = $target.children('.es.es-cell');\n\t\tvar cw = (this.getDim($target).width - gut*(cols-1))/cols;\n\t\t$cells.each(function(index){\n\t\t\t$(this).outerWidth(cw*cells[index] + gut*(cells[index]-1));\n\t\t});\n\t}\n\tGrid.prototype.getDim = function($obj){\n\t\treturn $obj[0].getBoundingClientRect();\n\t}\n})(jQuery);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvcmVzcC1zdHlsZS5qcz80NDQ0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLElBQUk7QUFDSiw0Q0FBNEM7QUFDNUM7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGLDZCQUE2QjtBQUM3QjtBQUNBLHVCQUF1QixvREFBb0QsY0FBYztBQUN6RjtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsbUVBQW1FLGtDQUFrQztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnREFBZ0QsY0FBYztBQUNyRjtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFNBQVM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsU0FBUztBQUNwRTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQ0FBcUMsUUFBUTtBQUNyRSxxQ0FBcUMsV0FBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QixpQ0FBaUMsU0FBUyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFDQUFxQyxRQUFRO0FBQ3JFLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZUFBZSxvQkFBb0I7QUFDM0MsK0NBQStDLFlBQVksT0FBTztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osNENBQTRDLFdBQVc7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVDQUF1QztBQUNuRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1DQUFtQztBQUNqRCwyQ0FBMkMsb0JBQW9CO0FBQy9ELG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBLCtEQUErRCxvQkFBb0I7QUFDbkYsa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBLEtBQUs7QUFDTCxtREFBbUQsWUFBWTtBQUMvRDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsK0JBQStCLDREQUE0RCxFQUFFO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCQpe1xuXHR2YXIgX2JwID0gWzMyMCwgNzY4LCAxMDI0LCAxMjgwXTtcblx0dmFyIHNldFNjcm9sbGJhckV2ZW50ID0gZmFsc2U7XG5cblx0JCh3aW5kb3cpLm9uKCdlcy1zZXRTY3JvbGxiYXJFdmVudCcsIGZ1bmN0aW9uKCl7XG5cdFx0aWYoc2V0U2Nyb2xsYmFyRXZlbnQgIT09IGZhbHNlKSByZXR1cm47XG5cdFx0c2V0U2Nyb2xsYmFyRXZlbnQgPSB0cnVlO1xuXG5cdFx0dmFyIHNjcm9sbGJhciA9ICh3aW5kb3cuaW5uZXJXaWR0aCAhPSAkKHdpbmRvdykub3V0ZXJXaWR0aCgpKTtcblx0XHRzZXRJbnRlcnZhbChmdW5jdGlvbigpe1xuXHRcdFx0aWYoc2Nyb2xsYmFyICYmIHdpbmRvdy5pbm5lcldpZHRoID09ICQod2luZG93KS5vdXRlcldpZHRoKCkpe1xuXHRcdFx0XHQkKHdpbmRvdykudHJpZ2dlcignZXMtY2hhbmdlU2Nyb2xsYmFyJyk7IHNjcm9sbGJhciA9IGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmKCFzY3JvbGxiYXIgJiYgd2luZG93LmlubmVyV2lkdGggIT0gJCh3aW5kb3cpLm91dGVyV2lkdGgoKSl7XG5cdFx0XHRcdCQod2luZG93KS50cmlnZ2VyKCdlcy1jaGFuZ2VTY3JvbGxiYXInKTsgc2Nyb2xsYmFyID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9LCAxMDApO1xuXHR9KTtcblx0JC5yZXNwU3R5bGUgPSBmdW5jdGlvbihhcmcpe2lmKGFyZyl7XG5cdFx0dmFyIGFycmF5ID0gYXJnLnNwbGl0KCcgJyk7XG5cdFx0aWYoYXJyYXkubGVuZ3RoIDwgMil7IGNvbnNvbGUuZXJyb3IoJ0Vycm9yOiB0aGUgbGVuZ3RoIG9mIGJyZWFrIHBvaW50cycpOyByZXR1cm4gZmFsc2U7IH1cblx0XHRfYnAgPSBbXTtcblx0XHRmb3IodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XG5cdFx0XHRpZigkLmlzTnVtZXJpYyhhcnJheVtpXSkpIF9icC5wdXNoKHBhcnNlRmxvYXQoYXJyYXlbaV0pKTtcblx0XHR9XG5cdH19XG5cdCQuZm4ucmVzcFN0eWxlID0gZnVuY3Rpb24oYXJnKXtcblx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5zZWxlY3Rvcjtcblx0XHQkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpe1xuXHRcdFx0cmVzcFN0eWxlKHRhcmdldCwgYXJnKTtcblx0XHR9KTtcblx0fVxuXHRmdW5jdGlvbiByZXNwU3R5bGUodGFyZ2V0LCBhcmcpe2lmKHRhcmdldCAmJiBhcmcpe1xuXHRcdCQodGFyZ2V0KS5lYWNoKGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgJHRhcmdldCA9ICQodGhpcyk7XG5cdFx0XHR2YXIgc3R5bGUgPSBuZXcgU3R5bGUoYXJnKTtcblx0XHRcdCR0YXJnZXQuY3NzKHN0eWxlLmNzcygpKTtcblx0XHRcdCQod2luZG93KS5yZXNpemUoZnVuY3Rpb24oKXtcblx0XHRcdFx0JHRhcmdldC5jc3Moc3R5bGUuY3NzKCkpO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH19XG5cdCQuZm4ucmVzcEdyaWQgPSBmdW5jdGlvbihhcmcpe1xuXHRcdHZhciB0YXJnZXQgPSB0aGlzLnNlbGVjdG9yO1xuXHRcdCQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXNwR3JpZCh0YXJnZXQsIGFyZyk7XG5cdFx0fSk7XG5cdH1cblx0ZnVuY3Rpb24gcmVzcEdyaWQodGFyZ2V0LCBhcmcpe2lmKHRhcmdldCAmJiBhcmcpe1xuXHRcdCQodGFyZ2V0KS5lYWNoKGZ1bmN0aW9uKCl7XG5cdFx0XHQkKHRoaXMpLmNzcygnb3ZlcmZsb3cnLCAnaGlkZGVuJyk7XG5cdFx0XHQkKHRoaXMpLmNoaWxkcmVuKCdkaXYnKS5hZGRDbGFzcygnZXMnKS5hZGRDbGFzcygnZXMtY2VsbCcpLmNzcyh7ZmxvYXQ6ICdsZWZ0Jywgb3ZlcmZsb3c6ICdoaWRkZW4nfSk7XG5cdFx0XHRpZigkKHRoaXMpLmlzKCcuZXMuZXMtY2VsbCcpKSAkKHRoaXMpLmFkZENsYXNzKCdlcy1uZXN0ZWQnKTtcblx0XHRcdHZhciAkdGFyZ2V0ID0gJCh0aGlzKTtcblx0XHRcdHZhciBncmlkID0gbmV3IEdyaWQoYXJnLCAkdGFyZ2V0LmNoaWxkcmVuKCcuZXMuZXMtY2VsbCcpLmxlbmd0aCk7XG5cdFx0XHRncmlkLmFkanVzdCgkdGFyZ2V0KTtcblx0XHRcdCQod2luZG93KS5yZXNpemUoZnVuY3Rpb24oKXtcblx0XHRcdFx0Z3JpZC5hZGp1c3QoJHRhcmdldCk7XG5cdFx0XHR9KTtcblx0XHRcdCQod2luZG93KS5vbignZXMtY2hhbmdlU2Nyb2xsYmFyJywgZnVuY3Rpb24oKXtcblx0XHRcdFx0Z3JpZC5hZGp1c3QoJHRhcmdldCwgZmFsc2UpO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH19XG5cblx0Ly8gc3R5bGUgLy8vL1xuXHRmdW5jdGlvbiBTdHlsZShhcmcpe1xuXHRcdHZhciB0aGlzX2RhdGEgPSB7fTtcblx0XHR2YXIgdGhpc19icCA9IHsgYnA6IHVuZGVmaW5lZCwgYnBpOiAwLCB3dzogMCB9O1xuXHRcdHZhciB0aGlzX3N0eWxlID0ge307XG5cdFx0dGhpcy5jc3MgPSBmdW5jdGlvbihjYWxjKXtcblx0XHRcdGlmKGNhbGMgPT09IHVuZGVmaW5lZCB8fCBjYWxjKSB0aGlzLmNhbGNTdHlsZSh0aGlzX2RhdGEsIHRoaXNfYnAsIHRoaXNfc3R5bGUpO1xuXHRcdFx0cmV0dXJuIHRoaXNfc3R5bGU7XG5cdFx0fVxuXHRcdC8vaW5pdGlhbGl6ZSAvLy8vXG5cdFx0aWYoYXJnKXtcblx0XHRcdHRoaXMuY29udlRvT2JqKGFyZywgdGhpc19kYXRhLCB0aGlzX2JwKTtcblx0XHRcdHRoaXMucG9zdENvbnYodGhpc19kYXRhLCB0aGlzX2JwKTtcblx0XHR9XG5cdH1cblx0U3R5bGUucHJvdG90eXBlLmNvbnZUb09iaiA9IGZ1bmN0aW9uKGFyZywgZGF0YSwgYnApe1xuXHRcdGZvcih2YXIgcHJvcCBpbiBhcmcpe1xuXHRcdFx0aWYocHJvcCAhPT0gJ2JyZWFrcG9pbnQnKXtcblx0XHRcdFx0ZGF0YVtwcm9wXSA9IHsgc2VyaWVzOiBbXSwgbWF4OiBmYWxzZSwgdW5pdDogJ3B4JywgZnVuYzogJ2xpbmVhcid9O1xuXHRcdFx0XHR0aGlzLmNvbnZUb09iakVhY2goYXJnW3Byb3BdLCBkYXRhW3Byb3BdKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJwLmJwID0gW107XG5cdFx0XHRcdHRoaXMuY29udlRvT2JqRWFjaChhcmdbcHJvcF0sIGJwLmJwKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYoYnAuYnAgPT09IHVuZGVmaW5lZCkgYnAuYnAgPSBfYnA7XG5cdH1cblx0U3R5bGUucHJvdG90eXBlLmNvbnZUb09iakVhY2ggPSBmdW5jdGlvbihwcm9wT2ZBcmcsIHByb3BPZkRhdGEpe1xuXHRcdHZhciBhcnJheSA9IHByb3BPZkFyZy5zcGxpdCgnICcpO1xuXHRcdGlmKGFycmF5Lmxlbmd0aCA8IDEpeyBjb25zb2xlLmVycm9yKCdFcnJvcjogdGhlIGxlbmd0aCBvZiBhcmd1bWVudCcpOyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZigkLnR5cGUocHJvcE9mRGF0YSkgPT09ICdvYmplY3QnKXtcblx0XHRcdGZvcih2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKXtcblx0XHRcdFx0aWYoJC5pc051bWVyaWMoYXJyYXlbaV0pKSBwcm9wT2ZEYXRhLnNlcmllcy5wdXNoKHBhcnNlRmxvYXQoYXJyYXlbaV0pKTtcblx0XHRcdFx0ZWxzZSBpZihhcnJheVtpXSA9PT0gJy0nIHx8IGFycmF5W2ldID09PSAnPScpIHByb3BPZkRhdGEuc2VyaWVzLnB1c2goYXJyYXlbaV0pO1xuXHRcdFx0XHRlbHNlIGlmKHRoaXMuaXNOb3ROdW1WYWwoYXJyYXlbaV0pKSBwcm9wT2ZEYXRhLnNlcmllcy5wdXNoKGFycmF5W2ldKTtcblx0XHRcdFx0ZWxzZSBpZih0aGlzLmlzVW5pdChhcnJheVtpXSkpIHByb3BPZkRhdGEudW5pdCA9IGFycmF5W2ldO1xuXHRcdFx0XHRlbHNlIGlmKGFycmF5W2ldID09PSAnbWF4JykgcHJvcE9mRGF0YS5tYXggPSB0cnVlO1xuXHRcdFx0XHRlbHNlIGlmKGFycmF5W2ldID09PSAnbGluZWFyJyB8fCBhcnJheVtpXSA9PT0gJ3N0ZXAnIHx8IGFycmF5W2ldID09PSAnc2F3JykgcHJvcE9mRGF0YS5mdW5jID0gYXJyYXlbaV07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmKCQudHlwZShwcm9wT2ZEYXRhKSA9PT0gJ2FycmF5Jyl7XG5cdFx0XHRmb3IodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XG5cdFx0XHRcdGlmKCQuaXNOdW1lcmljKGFycmF5W2ldKSkgcHJvcE9mRGF0YS5wdXNoKHBhcnNlRmxvYXQoYXJyYXlbaV0pKTtcblx0XHRcdFx0ZWxzZSBpZihhcnJheVtpXSA9PT0gJy0nIHx8IGFycmF5W2ldID09PSAnPScpIHByb3BPZkRhdGEucHVzaChhcnJheVtpXSk7XG5cdFx0XHRcdGVsc2UgaWYodGhpcy5pc05vdE51bVZhbChhcnJheVtpXSkpIHByb3BPZkRhdGEucHVzaChhcnJheVtpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFN0eWxlLnByb3RvdHlwZS5wb3N0Q29udiA9IGZ1bmN0aW9uKGRhdGEsIGJwKXtcblx0XHRmb3IodmFyIHByb3AgaW4gZGF0YSl7XG5cdFx0XHR0aGlzLnZhbGlkYXRlRWFjaChkYXRhW3Byb3BdLCBicC5icC5sZW5ndGgpO1xuXHRcdFx0dGhpcy5jYWxjTWlkZGxlRWFjaChkYXRhW3Byb3BdLCBicC5icCk7XG5cdFx0XHR0aGlzLmNhbGNFcXVhbEVhY2goZGF0YVtwcm9wXSk7XG5cdFx0fVxuXHR9XG5cdFN0eWxlLnByb3RvdHlwZS52YWxpZGF0ZUVhY2ggPSBmdW5jdGlvbihwcm9wT2ZEYXRhLCBicExlbmd0aCl7XG5cdFx0aWYoJC50eXBlKHByb3BPZkRhdGEpID09PSAnb2JqZWN0Jyl7XG5cdFx0XHRpZihwcm9wT2ZEYXRhLmZ1bmMgIT09ICdzYXcnICYmIHByb3BPZkRhdGEuc2VyaWVzLmxlbmd0aCA8IGJwTGVuZ3RoKXtcblx0XHRcdFx0Zm9yKHZhciBpID0gcHJvcE9mRGF0YS5zZXJpZXMubGVuZ3RoLCBsZW4gPSBicExlbmd0aDsgaSA8IGxlbjsgaSsrKXtcblx0XHRcdFx0XHRwcm9wT2ZEYXRhLnNlcmllc1tpXSA9IHByb3BPZkRhdGEuc2VyaWVzW2ktMV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYocHJvcE9mRGF0YS5mdW5jID09PSAnc2F3JyAmJiBwcm9wT2ZEYXRhLnNlcmllcy5sZW5ndGggPGJwTGVuZ3RoKjIpe1xuXHRcdFx0XHRmb3IodmFyIGkgPSBwcm9wT2ZEYXRhLnNlcmllcy5sZW5ndGgsIGxlbiA9IGJwTGVuZ3RoKjI7IGkgPCBsZW47IGkrKyl7XG5cdFx0XHRcdFx0cHJvcE9mRGF0YS5zZXJpZXNbaV0gPSBwcm9wT2ZEYXRhLnNlcmllc1tpLTFdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmKCQudHlwZShwcm9wT2ZEYXRhKSA9PT0gJ2FycmF5Jyl7XG5cdFx0XHRpZihwcm9wT2ZEYXRhLmxlbmd0aCA8IGJwTGVuZ3RoKXtcblx0XHRcdFx0Zm9yKHZhciBpID0gcHJvcE9mRGF0YS5sZW5ndGgsIGxlbiA9IGJwTGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuXHRcdFx0XHRcdHByb3BPZkRhdGFbaV0gPSBwcm9wT2ZEYXRhW2ktMV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0U3R5bGUucHJvdG90eXBlLmNhbGNNaWRkbGVFYWNoID0gZnVuY3Rpb24ocHJvcE9mRGF0YSwgYnApe1xuXHRcdHZhciBzZXJpZXM7XG5cdFx0aWYoJC50eXBlKHByb3BPZkRhdGEpID09PSAnb2JqZWN0Jykgc2VyaWVzID0gcHJvcE9mRGF0YS5zZXJpZXM7XG5cdFx0ZWxzZSBpZigkLnR5cGUocHJvcE9mRGF0YSkgPT09ICdhcnJheScpIHNlcmllcyA9IHByb3BPZkRhdGE7XG5cdFx0dmFyIHBuaSA9IDAsIG5uaSA9IDA7XG5cdFx0aWYoc2VyaWVzWzBdID09PSAnLScpeyBjb25zb2xlLmVycm9yKCdXcm9uZyB1c2FnZSBvZiBcIi1cIicpOyByZXR1cm47IH1cblx0XHRmb3IodmFyIGkgPSAwLCBsZW4gPSBzZXJpZXMubGVuZ3RoOyBpIDwgbGVuLTE7IGkrKyl7XG5cdFx0XHRpZigkLmlzTnVtZXJpYyhzZXJpZXNbaV0pKSBwbmkgPSBpO1xuXHRcdFx0aWYoc2VyaWVzW2ldID09PSAnLScpe1xuXHRcdFx0XHRpZihubmkgPT09IDAgfHwgbm5pIDwgaSl7XG5cdFx0XHRcdFx0Zm9yKHZhciBqID0gaSsxOyBqIDwgbGVuOyBqKyspe1xuXHRcdFx0XHRcdFx0aWYoJC5pc051bWVyaWMoc2VyaWVzW2pdKSl7IG5uaSA9IGo7IGJyZWFrOyB9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKG5uaSA9PT0gMCB8fCBubmkgPCBpKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdXcm9uZyB1c2FnZSBvZiBcIi1cIicpOyByZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHNlcmllc1tpXSA9IChzZXJpZXNbbm5pXSAtIHNlcmllc1twbmldKSAqIChicFtpXSAtIGJwW3BuaV0pIC8gKGJwW25uaV0gLSBicFtwbmldKSArIHNlcmllc1twbmldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHR9XG5cdFN0eWxlLnByb3RvdHlwZS5jYWxjRXF1YWxFYWNoID0gZnVuY3Rpb24ocHJvcE9mRGF0YSl7XG5cdFx0dmFyIHNlcmllcztcblx0XHRpZigkLnR5cGUocHJvcE9mRGF0YSkgPT09ICdvYmplY3QnKSBzZXJpZXMgPSBwcm9wT2ZEYXRhLnNlcmllcztcblx0XHRlbHNlIGlmKCQudHlwZShwcm9wT2ZEYXRhKSA9PT0gJ2FycmF5Jykgc2VyaWVzID0gcHJvcE9mRGF0YTtcblx0XHRpZihzZXJpZXNbMF0gPT09ICc9Jyl7IGNvbnNvbGUuZXJyb3IoJ1dyb25nIHVzYWdlIG9mIFwiPVwiJyk7IHJldHVybjsgfVxuXHRcdGZvcih2YXIgaSA9IDEsIGxlbiA9IHNlcmllcy5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XG5cdFx0XHRpZihzZXJpZXNbaV0gPT09ICc9Jykgc2VyaWVzW2ldID0gc2VyaWVzW2ktMV07XG5cdFx0fVxuXHR9XG5cdFN0eWxlLnByb3RvdHlwZS5jYWxjU3R5bGUgPSBmdW5jdGlvbihkYXRhLCBicCwgc3R5bGUpe1xuXHRcdHRoaXMuZmluZEJwKGJwKTtcblx0XHRmb3IodmFyIHByb3AgaW4gZGF0YSl7XG5cdFx0XHRpZighdGhpcy5pc05vdE51bVByb3AocHJvcCkpe1xuXHRcdFx0XHRzdHlsZVtwcm9wXSA9IHRoaXMuY2FsYyhkYXRhW3Byb3BdLCBicCkgKyBkYXRhW3Byb3BdLnVuaXQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzdHlsZVtwcm9wXSA9IHRoaXMucGljayhkYXRhW3Byb3BdLnNlcmllcywgYnApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRTdHlsZS5wcm90b3R5cGUuZmluZEJwID0gZnVuY3Rpb24oYnApe1xuXHRcdGJwLnd3ID0gd2luZG93LmlubmVyV2lkdGg7XG5cdFx0aWYoYnAud3cgPCBicC5icFswXSkgYnAuYnBpID0gLTE7XG5cdFx0ZWxzZSBpZihicC53dyA+PSAgYnAuYnBbYnAuYnAubGVuZ3RoLTFdKSBicC5icGkgPSAtMjtcblx0XHRlbHNlIHsgZm9yKHZhciBpID0gMDsgaSA8IGJwLmJwLmxlbmd0aC0xOyBpKyspe1xuXHRcdFx0aWYoYnAuYnBbaV0gPD0gYnAud3cgJiYgYnAud3cgPCBicC5icFtpKzFdKXsgYnAuYnBpID0gaTsgYnJlYWs7IH1cblx0XHR9fVxuXHR9XG5cdFN0eWxlLnByb3RvdHlwZS5waWNrID0gZnVuY3Rpb24oc2VyaWVzLCBicCl7XG5cdFx0aWYoYnAuYnBpID49IDApIHJldHVybiBzZXJpZXNbYnAuYnBpXTtcblx0XHRlbHNlIGlmKGJwLmJwaSA9PSAtMSkgcmV0dXJuIHNlcmllc1swXTtcblx0XHRlbHNlIGlmKGJwLmJwaSA9PSAtMikgcmV0dXJuIHNlcmllc1ticC5icC5sZW5ndGgtMV07XG5cdH1cblx0U3R5bGUucHJvdG90eXBlLmNhbGMgPSBmdW5jdGlvbihwcm9wT2ZEYXRhLCB0aGlzX2JwKXtcblx0XHR2YXIgc2VyaWVzID0gcHJvcE9mRGF0YS5zZXJpZXMsIG1heCA9IHByb3BPZkRhdGEubWF4LCBmdW5jID0gcHJvcE9mRGF0YS5mdW5jO1xuXHRcdHZhciBicCA9IHRoaXNfYnAuYnAsIGJwaSA9IHRoaXNfYnAuYnBpLCBsZW4gPSB0aGlzX2JwLmJwLmxlbmd0aCwgd3cgPSB0aGlzX2JwLnd3O1xuXHRcdHZhciBpO1xuXHRcdGlmKGJwaSA+PSAwKXtcblx0XHRcdGkgPSBicGk7XG5cdFx0fSBlbHNlIGlmKGJwaSA9PT0gLTEpe1xuXHRcdFx0cmV0dXJuIHNlcmllc1swXTtcblx0XHR9IGVsc2UgaWYoYnBpID09PSAtMil7XG5cdFx0XHRpZihtYXgpe1xuXHRcdFx0XHRpZihmdW5jICE9PSAnc2F3JykgcmV0dXJuIHNlcmllc1tsZW4tMV07XG5cdFx0XHRcdGVsc2UgaWYoZnVuYyA9PT0gJ3NhdycpIHJldHVybiBzZXJpZXNbMioobGVuLTEpKzFdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYoZnVuYyA9PT0gJ2xpbmVhcicgfHwgZnVuYyA9PT0gJ3NhdycpeyBpID0gbGVuLTI7IH1cblx0XHRcdFx0ZWxzZSBpZihmdW5jID09PSAnc3RlcCcpIGkgPSBsZW4gLSAxO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmKGZ1bmMgPT09ICdzdGVwJyl7XG5cdFx0XHRyZXR1cm4gc2VyaWVzW2ldO1xuXHRcdH0gZWxzZSBpZihmdW5jID09PSAnbGluZWFyJyl7XG5cdFx0XHRpZihicGkgPj0gMClcblx0XHRcdFx0cmV0dXJuIChzZXJpZXNbaSsxXSAtIHNlcmllc1tpXSkgKiAod3cgLSBicFtpXSkgLyAoYnBbaSsxXSAtIGJwW2ldKSArIHNlcmllc1tpXTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0cmV0dXJuIChzZXJpZXNbaSsxXSAtIHNlcmllc1tpXSkgKiAod3cgLSBicFtpKzFdKSAvIChicFtpKzFdIC0gYnBbaV0pICsgc2VyaWVzW2krMV07XG5cdFx0fSBlbHNlIGlmKGZ1bmMgPT09ICdzYXcnKXtcblx0XHRcdGlmKGJwaSA+PSAwKVxuXHRcdFx0XHRyZXR1cm4gKHNlcmllc1tpKjIrMV0gLSBzZXJpZXNbaSoyXSkgKiAod3cgLSBicFtpXSkgLyAoYnBbaSsxXSAtIGJwW2ldKSArIHNlcmllc1tpKjJdO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRyZXR1cm4gKHNlcmllc1tpKjIrM10gLSBzZXJpZXNbaSoyKzJdKSAqICh3dyAtIGJwW2ldKSAvIChicFtpKzFdIC0gYnBbaV0pICsgc2VyaWVzW2kqMisyXTtcblx0XHR9XG5cdH1cblx0U3R5bGUucHJvdG90eXBlLmlzVW5pdCA9IGZ1bmN0aW9uKHVuaXQpe1xuXHRcdHZhciB1bml0cyA9IFsnZW0nLCAnZXgnLCAnJScsICdweCcsICdjbScsICdtbScsICdpbicsICdwdCcsICdwYycsICdjaCcsICdyZW0nLCAndmgnLCAndncnLCAndm1pbicsICd2bWF4J107XG5cdFx0aWYoJC5pbkFycmF5KHVuaXQsIHVuaXRzKSA+IC0xKSByZXR1cm4gdHJ1ZTsgZWxzZSByZXR1cm4gZmFsc2U7XG5cdH1cblx0U3R5bGUucHJvdG90eXBlLmlzTm90TnVtVmFsID0gZnVuY3Rpb24odmFsdWUpe1xuXHRcdHZhciB2YWx1ZXMgPSBbJ2xlZnQnLCAncmlnaHQnLCAnbm9uZScsICdhYnNvbHV0ZScsICdmaXhlZCcsICdzdGF0aWMnLCAnaGlkZGVuJywgJ3Njcm9sbCcsICdhdXRvJyxcblx0XHRcdCdibG9jaycsICdpbmxpbmUnLCAnaW5saW5lLWJsb2NrJ107XG5cdFx0aWYoJC5pbkFycmF5KHZhbHVlLCB2YWx1ZXMpID4gLTEpIHJldHVybiB0cnVlOyBlbHNlIHJldHVybiBmYWxzZTtcblx0fVxuXHRTdHlsZS5wcm90b3R5cGUuaXNOb3ROdW1Qcm9wID0gZnVuY3Rpb24ocHJvcCl7XG5cdFx0dmFyIHByb3BzID0gWydmbG9hdCcsICdwb3NpdGlvbicsICdvdmVyZmxvdycsICdvdmVyZmxvdy14JywgJ292ZXJmbG93LXknLCAnZGlzcGxheSddO1xuXHRcdGlmKCQuaW5BcnJheShwcm9wLCBwcm9wcykgPiAtMSkgcmV0dXJuIHRydWU7IGVsc2UgcmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gZ3JpZCAvLy8vXG5cdGZ1bmN0aW9uIEdyaWQoYXJnLCBudW1DZWxsKXtcblx0XHR2YXIgdGhpc19kYXRhID0ge1xuXHRcdFx0Y29sdW1uczogW10sIHJhdGlvOiBbXSxcblx0XHRcdGd1dHRlcjoge3NlcmllczogW10sIG1heDogZmFsc2UsIGZ1bmM6ICdsaW5lYXInfSwgLy9ndXR0ZXLsnZggdW5pdOydgCBweC5cblx0XHRcdGNlbGxzOiBuZXcgQXJyYXkobnVtQ2VsbClcblx0XHR9O1xuXHRcdHZhciB0aGlzX2JwID0geyBicDogdW5kZWZpbmVkLCBicGk6IDAsIHd3OiAwIH07XG5cdFx0dmFyIHRoaXNfY3VycmVudCA9IHsgY29sdW1uczogMCwgcmF0aW86IDAsIGd1dHRlcjogMCAsIGNlbGxzOiBuZXcgQXJyYXkobnVtQ2VsbCkgfTtcblx0XHR0aGlzLmFkanVzdCA9IGZ1bmN0aW9uKCR0YXJnZXQsIGNlbGwpe1xuXHRcdFx0aWYoY2VsbCA9PT0gdW5kZWZpbmVkIHx8IGNlbGwpe1xuXHRcdFx0XHR0aGlzLmNhbGNDdXJyZW50KHRoaXNfZGF0YSwgdGhpc19icCwgdGhpc19jdXJyZW50KTtcblx0XHRcdFx0dGhpcy5hZGp1c3RDZWxsKHRoaXNfY3VycmVudCwgJHRhcmdldCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmFkanVzdENlbGxXaWR0aCh0aGlzX2N1cnJlbnQsICR0YXJnZXQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvL2luaXRpYWxpemUgLy8vL1xuXHRcdGlmKGFyZyl7XG5cdFx0XHR0aGlzLmNvbnZUb09iaihhcmcsIHRoaXNfZGF0YSwgdGhpc19icCk7XG5cdFx0XHR0aGlzLnBvc3RDb252KHRoaXNfZGF0YSwgdGhpc19icCk7XG5cdFx0fVxuXHR9XG5cdEdyaWQucHJvdG90eXBlID0gbmV3IFN0eWxlKCk7XG5cdEdyaWQucHJvdG90eXBlLmNvbnZUb09iaiA9IGZ1bmN0aW9uKGFyZywgZGF0YSwgYnApe1xuXHRcdGlmKGFyZy5icmVha3BvaW50KXtcblx0XHRcdGJwLmJwID0gW107IHRoaXMuY29udlRvT2JqRWFjaChhcmcuYnJlYWtwb2ludCwgYnAuYnApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRicC5icCA9IF9icDtcblx0XHR9XG5cdFx0Zm9yKHZhciBwcm9wIGluIGFyZyl7XG5cdFx0XHRpZihkYXRhW3Byb3BdKSB0aGlzLmNvbnZUb09iakVhY2goYXJnW3Byb3BdLCBkYXRhW3Byb3BdKTtcblx0XHRcdGVsc2UgaWYocHJvcC5tYXRjaCgvXmNlbGwvKSl7XG5cdFx0XHRcdHZhciBpbmRleCA9IHBhcnNlSW50KHByb3AucmVwbGFjZSgvXmNlbGwvLCAnJykpO1xuXHRcdFx0XHRkYXRhLmNlbGxzW2luZGV4XSA9IFtdO1xuXHRcdFx0XHR0aGlzLmNvbnZUb09iakVhY2goYXJnW3Byb3BdLCBkYXRhLmNlbGxzW2luZGV4XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdEdyaWQucHJvdG90eXBlLnBvc3RDb252ID0gZnVuY3Rpb24oZGF0YSwgYnApe1xuXHRcdGZvcih2YXIgcHJvcCBpbiBkYXRhKXtcblx0XHRcdGlmKHByb3AgIT09ICdjZWxscycpe1xuXHRcdFx0XHR0aGlzLnZhbGlkYXRlRWFjaChkYXRhW3Byb3BdLCBicC5icC5sZW5ndGgpO1xuXHRcdFx0XHR0aGlzLmNhbGNNaWRkbGVFYWNoKGRhdGFbcHJvcF0sIGJwLmJwKTtcblx0XHRcdFx0dGhpcy5jYWxjRXF1YWxFYWNoKGRhdGFbcHJvcF0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yKHZhciBpID0gMCwgbGVuID0gZGF0YVtwcm9wXS5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XG5cdFx0XHRcdFx0aWYoZGF0YVtwcm9wXVtpXSl7XG5cdFx0XHRcdFx0XHR0aGlzLnZhbGlkYXRlRWFjaChkYXRhW3Byb3BdW2ldLCBicC5icC5sZW5ndGgpO1xuXHRcdFx0XHRcdFx0dGhpcy5jYWxjTWlkZGxlRWFjaChkYXRhW3Byb3BdW2ldLCBicCk7XG5cdFx0XHRcdFx0XHR0aGlzLmNhbGNFcXVhbEVhY2goZGF0YVtwcm9wXVtpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdEdyaWQucHJvdG90eXBlLmNhbGNDdXJyZW50ID0gZnVuY3Rpb24oZGF0YSwgdGhpc19icCwgY3VycmVudCl7XG5cdFx0dGhpcy5maW5kQnAodGhpc19icCk7XG5cdFx0Y3VycmVudC5ndXR0ZXIgPSB0aGlzLmNhbGMoZGF0YS5ndXR0ZXIsIHRoaXNfYnApO1xuXHRcdHZhciBicGk7XG5cdFx0aWYodGhpc19icC5icGkgPj0gMCkgYnBpID0gdGhpc19icC5icGk7XG5cdFx0ZWxzZSBpZih0aGlzX2JwLmJwaSA9PT0gLTIpIGJwaSA9IHRoaXNfYnAuYnAubGVuZ3RoLTE7XG5cdFx0ZWxzZSBpZih0aGlzX2JwLmJwaSA9PT0gLTEpIGJwaSA9IDA7XG5cdFx0Y3VycmVudC5jb2x1bW5zID0gZGF0YS5jb2x1bW5zW2JwaV07XG5cdFx0Y3VycmVudC5yYXRpbyA9IGRhdGEucmF0aW9bYnBpXTtcblx0XHRmb3IodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmNlbGxzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKXtcblx0XHRcdCBpZihkYXRhLmNlbGxzW2ldKSBjdXJyZW50LmNlbGxzW2ldID0gZGF0YS5jZWxsc1tpXVticGldO1xuXHRcdFx0IGVsc2UgY3VycmVudC5jZWxsc1tpXSA9IDE7XG5cdFx0fVxuXHR9XG5cdEdyaWQucHJvdG90eXBlLmFkanVzdENlbGwgPSBmdW5jdGlvbihjdXJyZW50LCAkdGFyZ2V0KXtcblx0XHR2YXIgcHJlVyA9ICR0YXJnZXQub3V0ZXJXaWR0aCgpO1xuXHRcdHZhciBndXQgPSBjdXJyZW50Lmd1dHRlcjtcblx0XHR2YXIgY29scyA9IGN1cnJlbnQuY29sdW1ucztcblx0XHR2YXIgY2VsbHMgPSBjdXJyZW50LmNlbGxzO1xuXHRcdHZhciAkY2VsbHMgPSAkdGFyZ2V0LmNoaWxkcmVuKCcuZXMuZXMtY2VsbCcpO1xuXHRcdHZhciBsZW5ndGggPSAkY2VsbHMubGVuZ3RoO1xuXHRcdHZhciBjdyA9ICh0aGlzLmdldERpbSgkdGFyZ2V0KS53aWR0aCAtIGd1dCooY29scy0xKSkvY29scztcblx0XHR2YXIgbWF4Q2ggPSAwO1xuXHRcdCRjZWxscy5jc3MoeydtYXJnaW4tcmlnaHQnOiAwLCAnbWFyZ2luLXRvcCc6IDB9KTtcblx0XHRpZihjdXJyZW50LnJhdGlvICE9PSAnYXV0bycpICRjZWxscy5jc3Moe3dpZHRoOiAwLCBoZWlnaHQ6IDB9KTtcblx0XHRlbHNlICRjZWxscy5jc3Moe3dpZHRoOiAwLCBoZWlnaHQ6IDB9KTtcblx0XHQkY2VsbHMuZWFjaChmdW5jdGlvbihpbmRleCl7XG5cdFx0XHQkKHRoaXMpLm91dGVyV2lkdGgoY3cqY2VsbHNbaW5kZXhdICsgZ3V0KihjZWxsc1tpbmRleF0tMSkpO1xuXHRcdFx0aWYoKGluZGV4KzEpICUgY29scyAhPT0gMCAmJiBpbmRleCA8IGxlbmd0aC0xKSAkKHRoaXMpLmNzcyh7J21hcmdpbi1yaWdodCc6IGd1dH0pO1xuXHRcdFx0aWYoaW5kZXggPj0gY29scykgJCh0aGlzKS5jc3MoeydtYXJnaW4tdG9wJzogZ3V0fSk7XG5cdFx0XHRpZihjdXJyZW50LnJhdGlvID09PSAnYXV0bycpe1xuXHRcdFx0XHQkKHRoaXMpLmNzcyh7aGVpZ2h0OiAnJ30pO1xuXHRcdFx0XHRpZihtYXhDaCA8IHRoaXMuZ2V0RGltKCQodGhpcykpLmhlaWdodCkgbWF4Q2ggPSB0aGlzLmdldERpbSgkKHRoaXMpKS5oZWlnaHQ7XG5cdFx0XHRcdGlmKGNvbHMgIT09IDEgJiYgKGluZGV4KzEpICUgY29scyA9PT0gMCl7XG5cdFx0XHRcdFx0Zm9yKHZhciBpID0gaW5kZXggLSBjb2xzICsgMTsgaSA8PSBpbmRleDsgaSsrKSAkY2VsbHMuZXEoaSkub3V0ZXJIZWlnaHQobWF4Q2gpO1xuXHRcdFx0XHRcdG1heENoID0gMDtcblx0XHRcdFx0fSBlbHNlIGlmKGNvbHMgIT09IDEgJiYgaW5kZXggPT09IGxlbmd0aC0xKSB7XG5cdFx0XHRcdFx0Zm9yKHZhciBpID0gTWF0aC5mbG9vcigoaW5kZXgrMSkvY29scykgKiBjb2xzOyBpIDw9IGluZGV4OyBpKyspICRjZWxscy5lcShpKS5vdXRlckhlaWdodChtYXhDaCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBoZWlnaHQgPSBjdyAqIGN1cnJlbnQucmF0aW87XG5cdFx0XHRcdGlmKCR0YXJnZXQuaXMoJy5lcy5lcy1uZXN0ZWQnKSkgaGVpZ2h0IC09IChndXQgLSBndXQvTWF0aC5jZWlsKGxlbmd0aC9jb2xzKSk7XG5cdFx0XHRcdCQodGhpcykub3V0ZXJIZWlnaHQoaGVpZ2h0KTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRpZihwcmVXICE9ICR0YXJnZXQub3V0ZXJXaWR0aCgpKXtcblx0XHRcdGN3ID0gKHRoaXMuZ2V0RGltKCR0YXJnZXQpLndpZHRoIC0gZ3V0Kihjb2xzLTEpKS9jb2xzO1xuXHRcdFx0JGNlbGxzLmVhY2goZnVuY3Rpb24oaW5kZXgpeyAkKHRoaXMpLm91dGVyV2lkdGgoY3cqY2VsbHNbaW5kZXhdICsgZ3V0KihjZWxsc1tpbmRleF0tMSkpOyB9KTtcblx0XHR9XG5cdH1cblx0R3JpZC5wcm90b3R5cGUuYWRqdXN0Q2VsbFdpZHRoID0gZnVuY3Rpb24oY3VycmVudCwgJHRhcmdldCl7XG5cdFx0dmFyIGd1dCA9IGN1cnJlbnQuZ3V0dGVyO1xuXHRcdHZhciBjb2xzID0gY3VycmVudC5jb2x1bW5zO1xuXHRcdHZhciBjZWxscyA9IGN1cnJlbnQuY2VsbHM7XG5cdFx0dmFyICRjZWxscyA9ICR0YXJnZXQuY2hpbGRyZW4oJy5lcy5lcy1jZWxsJyk7XG5cdFx0dmFyIGN3ID0gKHRoaXMuZ2V0RGltKCR0YXJnZXQpLndpZHRoIC0gZ3V0Kihjb2xzLTEpKS9jb2xzO1xuXHRcdCRjZWxscy5lYWNoKGZ1bmN0aW9uKGluZGV4KXtcblx0XHRcdCQodGhpcykub3V0ZXJXaWR0aChjdypjZWxsc1tpbmRleF0gKyBndXQqKGNlbGxzW2luZGV4XS0xKSk7XG5cdFx0fSk7XG5cdH1cblx0R3JpZC5wcm90b3R5cGUuZ2V0RGltID0gZnVuY3Rpb24oJG9iail7XG5cdFx0cmV0dXJuICRvYmpbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdH1cbn0pKGpRdWVyeSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXBwL3Jlc3Atc3R5bGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ]);